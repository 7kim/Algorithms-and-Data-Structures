# [:arrow_left:](../README.md) DEFINATIONS

## :octocat: Algorithms

Algorithms are the series of steps which have no ambiguity that we follow to solve some problem.

## :octocat: Data Structures

Data Structures are the Structures formed by Data Types which makes our code efficient and we can use data in a systematic way. For example Stacks,Queues,Lists,arrays,etc.There are two types of Data Structures:

### :rocket: Linear Data Structures

Data Structures in which data is organised linear and in sequential order. For example

* Arrays,
* Lists,
* Queues,etc.

### :rocket: Non Linear Data Structures

Data Structures in which data is organised in non linear and in non-sequential order. For example

* Trees,
* Graphs,etc.

## :octocat: BEST CASE

The minimum time in which an Algorithm is solved. It is denoted using Big Omega Notation.

## :octocat: AVERAGE CASE

The time calculated by average of best case and worst case.

## :octocat: WORST CASE

The maximum time in which an Algorithm is solved. It is denoted using Big O Notation.

## :octocat: RATE OF GROWTH

The rate of growth is the growth at which our algorithm is increasing i.e order of complexity increases.

## :octocat: ASYMTOTIC NOTATIONS

There are total five types of Notations

### 1. Big O Notation (O)

* Big O Notation is a way of expressing the complexity related to number of items that an algorthm will deal with.
* It will tell for how many inputs the algorithm will support.
* It is represented by **O()**.
* It will tell us the **Worst Case (Maximum time to solve the problem)** of the Algorithm.
* Theoritically

```bash
f(n) <= c * g(n)
```

### 2. Big Omega Notation (Ω)

```bash
f(n) >= c * g(n)
```

### 3. Big Theta Notation (θ)

```bash
f(n) = c * g(n)
```

### 4. Little O Notation (o)

```bash
f(n) < c * g(n)
```

### 5. Little Omega Notation (ω)

```bash
f(n) > c * g(n)
```